function jarred_presets(coll, tree) {
    for(var host in tree) {
        var hdata = tree[host];
        coll.add_section(host);
        var mdata = [];
        if(hdata.memory) {
            for(var name in hdata.memory.default.memory) {
                mdata.push({
                "label": "Memory " + name,
                "yaxis": 2,
                "stack": true,
                "lines": { "show": true, "fill": true},
                "node": hdata.memory.default.memory[name]
                });
            }
        }
        if(hdata.cpu) {
            var ncpu = 0;
            for(var i in hdata.cpu) {
                if(!isNaN(i = parseInt(i)) && i+1 > ncpu)
                    ncpu = i+1;
            }
            coll.add_graph({
                "title": "CPU vs Memory",
                "ranges": {'yaxis': { 'minto': 100 } },
                }, mdata.concat([{
                "node": hdata.cpu,
                "fetch": "*/cpu-*/cpu-idle.rrd",
                "yaxis": 1,
                "ncpu": ncpu,
                "convert": function () {
                    var data = jarred.sum(arguments,
                        function(val) { return Math.max(100 - val, 0); });
                    data[0].label = "CPU (max "+(100*this.ncpu)+"%)";
                    return data;
                    }
                }]));
        }
        if(hdata.nginx) {
            coll.add_graph({
                "title": "Nginx requests"
                }, [{
                "yaxis": 2,
                "node": hdata.nginx.default.nginx_requests.default
                }])
        }
        if(hdata.processes) {
            for(var pname in hdata.processes) {
                var proc = hdata.processes[pname];
                if(pname == 'default') continue;
                coll.add_graph({
                    "title": pname + ' (CPU)'
                    }, [{
                    "yaxis": 1,
                    "node": proc.ps_cputime.default
                    }]);
                coll.add_graph({
                    "title": pname + ' (Memory)'
                    }, [{
                    "yaxis": 1,
                    "node": proc.ps_rss.default
                    }]);
            }
        }
    }
    coll.add_section('Roundtrips');
    var tping = {};
    var tdrop = {};
    for(var host in tree) {
        var hdata = tree[host];
        if(hdata.ping) {
            for(var k in hdata.ping.default.ping) {
                if(!tping[k]) {
                    tdrop[k] = [];
                    tping[k] = [];
                }
                tping[k].push([host, hdata.ping.default.ping[k]]);
                tdrop[k].push([host, hdata.ping.default.ping_droprate[k]]);
            }
        }
    }
    for(var n in tping) {
        var gdata = [];
        var p = tping[n];
        var d = tdrop[n];
        for(var i = 0, ni = p.length; i < ni; ++i) {
            gdata.push({
                "node": p[i][1],
                "yaxis": 1,
                "label": "Ping from " + p[i][0]
                });
            gdata.push({
                "node": d[i][1],
                "yaxis": 2,
                "label": "Drop rate " + d[i][0]
                });
        }
        coll.add_graph({
            "title": n
            }, gdata);
    }
}
